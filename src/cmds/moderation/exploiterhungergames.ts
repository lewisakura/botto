import { sendIRSNotice } from '../../utils/economy/irs';
import { CommandContext } from '../../types';

import { districts, weapons } from '../../utils/hungerGames';
import { cryptoRand, cryptoRandRange } from '../../utils/qrng';
import Eris from 'eris';

async function shuffleArray(array: any[]) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

function delay(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

let gameRunning = false;

async function exec(ctx: CommandContext) {
    if (gameRunning) return ctx.reply(ctx.config.emoji.error + ' A game is already running.');
    gameRunning = true;

    const overwrites = ctx.msg.channel.permissionOverwrites.find(o => o.id === ctx.config.verifiedRole);
    try {
        const exploiters = ctx.msg.channel.guild.members.filter(m => m.roles.includes(ctx.config.exploiterRole));
        if (exploiters.length < 2)
            return ctx.reply(
                ctx.config.emoji.error +
                    ' There are not enough exploiters to start a hunger games. <:sobbing:860488154150993920>'
            );

        shuffleArray(exploiters);

        const exploiter1 = exploiters[0];
        const exploiter1District = await cryptoRandRange(1, 14);
        const exploiter2 = exploiters[1];
        const exploiter2District = await cryptoRandRange(1, 14);

        if (ctx.getUserStaffLevel(exploiter1) > 0 || ctx.getUserStaffLevel(exploiter2) > 0) {
            return ctx.reply(
                ctx.config.emoji.error +
                    ' One of the participants has a higher admin level than 0. Please stop adding staff members to the hunger games.'
            );
        }

        await ctx.reply(
            ctx.config.emoji.bottobux +
                " **PLACE YOUR BETS!** Send your bets in this format: `<exploiter number> <bet>` (e.g., to bet 100 on exploiter 1, you'd write `1 100`). Make sure your money is on hand first before betting! It's a 5x multiplier!\n\n" +
                'Exploiter #1: ' +
                exploiter1.mention +
                '\n' +
                'Exploiter #2: ' +
                exploiter2.mention
        );
        const bets = await ctx.awaitMessages(
            ctx.msg.channel,
            m => {
                const valid = !!m.content.match(/^(1|2) \d+$/);
                if (valid) {
                    m.addReaction(ctx.config.emoji.bottobux.substring(2, ctx.config.emoji.bottobux.length - 1));
                    return true;
                } else {
                    return false;
                }
            },
            {
                maxMatches: Infinity,
                time: 30000
            }
        );

        const betMsg = await ctx.reply({
            content: ctx.config.emoji.loading + ' Processing bets, please wait...',
            messageReference: null
        });

        const badBets: string[] = [];
        const fixedBets: { id: string; who: number; bet: number }[] = [];
        for (const bet of bets) {
            const betInfo = bet.content.split(' ');

            const wallet = await ctx.db.wallet.findUnique({ where: { id: bet.author.id } });
            if (!wallet) {
                badBets.push(
                    `<@${bet.author.id}>, you don't have a wallet! Create one with \`;createwallet\` in <#${ctx.config.economyChannel}>.`
                );
                continue;
            }

            const fixedBetInfo = {
                id: bet.author.id,
                who: parseInt(betInfo[0]),
                bet: parseInt(betInfo[1])
            };

            if (fixedBetInfo.bet <= 0) {
                badBets.push(`<@${bet.author.id}>, you can't bet nothing!`);
                continue;
            }
            if (fixedBetInfo.bet > 10000000) {
                badBets.push(`<@${bet.author.id}>, you can't bet over 10,000,000!`);
                continue;
            }
            if (fixedBetInfo.bet > wallet.onHand) {
                badBets.push(`<@${bet.author.id}>, you don't have enough money on hand for that bet!`);
                continue;
            }

            const existingBet = fixedBets.find(fBet => fBet.id === bet.author.id);
            if (existingBet) {
                existingBet.who = parseInt(betInfo[0]);
                existingBet.bet = parseInt(betInfo[1]);
                continue;
            }

            fixedBets.push(fixedBetInfo);
        }

        await betMsg.edit(
            ctx.config.emoji.success +
                ' The following bets were placed:\n\n' +
                fixedBets
                    .map(
                        b =>
                            `<@${b.id}> on exploiter #${b.who} for ${b.bet.toLocaleString()} ${
                                ctx.config.emoji.bottobux
                            }`
                    )
                    .join('\n') +
                '\n\nThe following bets were invalid:\n\n' +
                badBets.join('\n')
        );

        const transactions = [];
        for (const bet of fixedBets) {
            sendIRSNotice(
                ctx,
                `⚔️ <@${bet.id}> placed a bet of ${bet.bet.toLocaleString()} ${
                    ctx.config.emoji.bottobux
                } on the hunger games.`
            );
            transactions.push(
                ctx.db.wallet.update({
                    where: {
                        id: bet.id
                    },
                    data: {
                        onHand: {
                            decrement: bet.bet
                        }
                    }
                })
            );
        }
        await ctx.db.$transaction(transactions);

        await ctx.msg.channel.editPermission(
            ctx.config.verifiedRole,
            overwrites.allow ^ 2048n,
            overwrites.deny | 2048n,
            Eris.Constants.PermissionOverwriteTypes.ROLE
        );

        let msgContents = `**HUNGER GAMES**\n${exploiter1.mention} (from District ${exploiter1District} (${districts[exploiter1District]})) vs ${exploiter2.mention} (from District ${exploiter2District} (${districts[exploiter2District]}))\n**FIGHT!**\n\n`;
        let hungerGames = await ctx.reply({ content: msgContents, messageReference: null });

        async function appendToContent(msg: string) {
            if ((msgContents + msg).length > 2000) {
                hungerGames = await ctx.reply({ content: '[reserved]', messageReference: null });
                msgContents = '';
            }
            msgContents += msg;
            await hungerGames.edit(msgContents);
        }

        await delay(1000);

        let turn = 0;
        let exploiter1Health = 100;
        let exploiter2Health = 100;
        let winner: number;
        let winnerId: string;
        while (true) {
            turn++;

            const weapon1 = weapons[await cryptoRandRange(0, weapons.length - 1)];
            const damage1 = await weapon1.damage();

            await appendToContent(
                `__TURN ${turn}__\n${exploiter1.mention} uses ${weapon1.name} for ${damage1} damage.\n`
            );
            exploiter2Health -= damage1;

            if (exploiter2Health <= 0) {
                await appendToContent(`${exploiter2.mention} has died. **BANNED!**`);
                await exploiter2.ban(0, 'Lost the hunger games');
                winner = 1;
                winnerId = exploiter1.id;
                break;
            }

            await delay(3000);

            const weapon2 = weapons[await cryptoRandRange(0, weapons.length - 1)];
            const damage2 = await weapon2.damage();

            await appendToContent(`${exploiter2.mention} uses ${weapon2.name} for ${damage2} damage.\n`);
            exploiter1Health -= damage2;

            if (exploiter1Health <= 0) {
                await appendToContent(`${exploiter1.mention} has died. **BANNED!**`);
                await exploiter1.ban(0, 'Lost the hunger games');
                winner = 2;
                winnerId = exploiter2.id;
                break;
            }

            await delay(1000);
            await appendToContent(
                `\nFinal health: ${exploiter1.mention} with ${exploiter1Health} HP and ${exploiter2.mention} with ${exploiter2Health} HP\n\n`
            );
            await delay(5000);
        }

        const transactionsWin = [];
        for (const bet of fixedBets) {
            if (bet.who === winner) {
                sendIRSNotice(
                    ctx,
                    `⚔️ <@${bet.id}> won ${(bet.bet * 5).toLocaleString()} ${
                        ctx.config.emoji.bottobux
                    } from the hunger games.`
                );
                transactionsWin.push(
                    ctx.db.wallet.update({
                        where: {
                            id: bet.id
                        },
                        data: {
                            onHand: {
                                increment: bet.bet * 5
                            }
                        }
                    })
                );
            }
        }
        await ctx.db.$transaction(transactionsWin);

        await ctx.db.user.upsert({
            where: {
                id: winnerId
            },
            create: {
                id: winnerId,
                hungerGamesWins: 1
            },
            update: {
                hungerGamesWins: {
                    increment: 1
                }
            }
        });
    } finally {
        await ctx.msg.channel.editPermission(
            ctx.config.verifiedRole,
            overwrites.allow,
            overwrites.deny,
            Eris.Constants.PermissionOverwriteTypes.ROLE
        );
        gameRunning = false;
    }
}

export default {
    name: 'exploiterhungergames',
    description: 'Let the exploiter hunger games begin!',
    aliases: ['ehg', 'ehungergames'],

    exec,
    level: 2
};
